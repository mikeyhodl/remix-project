import { v4 as uuidv4 } from 'uuid';
import { PluginClient } from '@remixproject/plugin';
import { DappConfig } from '../types/dapp';

const BASE_PATH = 'dapps';

export class DappManager {
  private plugin: PluginClient;

  constructor(plugin: PluginClient) {
    this.plugin = plugin;
  }

  private normalizeLogo(logo: any): string | null {
    if (!logo) return null;

    if (typeof logo === 'string') {
      if (logo === '[object Object]') return null;
      return logo;
    }

    if (logo && logo.type === 'Buffer' && Array.isArray(logo.data)) {
      try {
        const base64 = btoa(
          new Uint8Array(logo.data).reduce((data, byte) => data + String.fromCharCode(byte), '')
        );
        return `data:image/jpeg;base64,${base64}`;
      } catch (e) {
        console.warn('[DappManager] Failed to convert Buffer logo', e);
        return null;
      }
    }

    if (logo instanceof ArrayBuffer || logo instanceof Uint8Array || (logo as any).buffer) {
      try {
        const buffer = logo instanceof ArrayBuffer ? logo : (logo as any).buffer || logo;
        const base64 = btoa(
          new Uint8Array(buffer).reduce((data, byte) => data + String.fromCharCode(byte), '')
        );
        return `data:image/jpeg;base64,${base64}`;
      } catch (e) {
        return null;
      }
    }

    return null;
  }

  private sanitizeConfig(config: DappConfig): DappConfig {
    if (config.config && config.config.logo) {
      config.config.logo = this.normalizeLogo(config.config.logo) as string | undefined;
    }
    return config;
  }

  async ensureBasePath() {
    try {
      await this.plugin.call('fileManager', 'readdir', BASE_PATH);
    } catch (e) {
      console.log('[DappManager] Creating base path:', BASE_PATH);
      await this.plugin.call('fileManager', 'mkdir', BASE_PATH);
    }
  }

  async getDapps(): Promise<DappConfig[]> {
    try {
      try {
        await this.ensureBasePath();
      } catch (e) {
        return [];
      }

      const files = await this.plugin.call('fileManager', 'readdir', BASE_PATH);
      if (!files || typeof files !== 'object') {
        return [];
      }

      const configs: DappConfig[] = [];

      for (const [rawPath, info] of Object.entries(files)) {
        // @ts-ignore
        if (info.isDirectory) {
          try {
            const pathParts = rawPath.split('/');
            const slug = pathParts[pathParts.length - 1];
            if (!slug || slug === BASE_PATH) continue;

            const configPath = `${BASE_PATH}/${slug}/dapp.config.json`;

            let content;
            try {
              content = await this.plugin.call('fileManager', 'readFile', configPath);
            } catch (err) {
              continue;
            }

            if (content) {
              const config = JSON.parse(content);
              config.slug = slug;

              try {
                const previewPath = `${BASE_PATH}/${slug}/preview.png`;
                const previewContent = await this.plugin.call('fileManager', 'readFile', previewPath);
                if (previewContent) {
                  config.thumbnailPath = previewContent;
                }
              } catch (e) {}
              configs.push(this.sanitizeConfig(config));
            }
          } catch (e) {
            console.warn(`[DappManager] Failed to read config for ${rawPath}`, e);
          }
        }
      }
      return (configs || []).sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0));
    } catch (e) {
      console.error('[DappManager] Critical error loading dapps:', e);
      return [];
    }
  }

  async createDapp(name: string, contractData: any, isBaseMiniApp: boolean = false): Promise<DappConfig> {
    const id = uuidv4();

    console.log(`[DappManager] Creating Dapp: ${name}, isBaseMiniApp: ${isBaseMiniApp}`);

    const slug = `${name.toLowerCase().replace(/[^a-z0-9]+/g, '-')}-${id.slice(0, 6)}`;
    const folderPath = `${BASE_PATH}/${slug}`;
    const timestamp = Date.now();

    const initialConfig: DappConfig = {
      _warning: "DO NOT EDIT THIS FILE MANUALLY. MANAGED BY QUICK DAPP.",
      id,
      slug,
      name,
      contract: {
        address: contractData.address,
        name: contractData.name,
        abi: contractData.abi,
        chainId: contractData.chainId,
        networkName: contractData.networkName || 'Unknown Network'
      },
      status: 'draft',
      createdAt: timestamp,
      updatedAt: timestamp,
      config: {
        title: name,
        details: 'Generated by AI',
        isBaseMiniApp: isBaseMiniApp
      }
    };

    await this.plugin.call('fileManager', 'mkdir', folderPath);
    await this.saveConfig(slug, initialConfig);
    await this.plugin.call('fileManager', 'mkdir', `${folderPath}/src`);

    if (isBaseMiniApp) {
      console.log('[DappManager] Generating .well-known/farcaster.json for Base Mini App');
      try {
        await this.plugin.call('fileManager', 'mkdir', `${folderPath}/.well-known`);

        const manifestContent = {
          "accountAssociation": {
            "header": "",
            "payload": "",
            "signature": ""
          },
          "miniapp": {
            "version": "1",
            "name": name,
            "homeUrl": "https://CHANGE_ME_TO_IPFS_URL",
            "iconUrl": "https://github.com/remix-project-org.png",
            "splashImageUrl": "https://github.com/remix-project-org.png",
            "splashBackgroundColor": "#000000",
            "subtitle": "Base Mini App",
            "description": "Generated by Remix Quick Dapp",
            "screenshotUrls": [],
            "primaryCategory": "social",
            "tags": ["remix", "base-mini-app"],
            "heroImageUrl": "https://github.com/remix-project-org.png",
            "tagline": "Built on Base",
            "ogTitle": name,
            "ogDescription": "Check out this mini app",
            "ogImageUrl": "https://github.com/remix-project-org.png",
            "noindex": true
          }
        };

        await this.plugin.call('fileManager', 'writeFile', `${folderPath}/.well-known/farcaster.json`, JSON.stringify(manifestContent, null, 2));
      } catch (e) {
        console.error('[DappManager] Failed to create .well-known folder or file', e);
      }
    }

    return initialConfig;
  }

  async saveConfig(slug: string, config: DappConfig): Promise<void> {
    config.updatedAt = Date.now();
    const sanitized = this.sanitizeConfig(config);
    const content = JSON.stringify(sanitized, null, 2);
    const configPath = `${BASE_PATH}/${slug}/dapp.config.json`;
    await this.plugin.call('fileManager', 'writeFile', configPath, content);
  }

  async saveGeneratedFiles(slug: string, pages: Record<string, string>) {
    console.log(`[DEBUG-MANAGER] saveGeneratedFiles called for ${slug}`);
    const basePath = `${BASE_PATH}/${slug}`;

    if (!pages || Object.keys(pages).length === 0) {
      console.warn('[DEBUG-MANAGER] ⚠️ No pages to save.');
      return;
    }

    for (const [rawFilename, content] of Object.entries(pages)) {
      console.log(`[DEBUG-MANAGER] Processing file: ${rawFilename}`);

      const safeParts = rawFilename.replace(/\\/g, '/')
        .split('/')
        .filter(part => part !== '..' && part !== '.' && part !== '');

      if (safeParts.length === 0) continue;

      const fullPath = `${basePath}/${safeParts.join('/')}`;

      if (safeParts.length > 1) {
        const subFolders = safeParts.slice(0, -1);
        let currentPath = basePath;
        for (const folder of subFolders) {
          currentPath = `${currentPath}/${folder}`;
          try {
            await this.plugin.call('fileManager', 'mkdir', currentPath);
          } catch (e) {}
        }
      }

      try {
        await this.plugin.call('fileManager', 'writeFile', fullPath, content);
        console.log(`[DEBUG-MANAGER] ✅ Wrote: ${fullPath}`);
      } catch (e) {
        console.error(`[DEBUG-MANAGER] ❌ Failed to write ${fullPath}:`, e);
      }
    }
  }

  async deleteDapp(slug: string): Promise<void> {
    await this.plugin.call('fileManager', 'remove', `${BASE_PATH}/${slug}`);
  }

  async deleteAllDapps(): Promise<void> {
    const dapps = await this.getDapps();
    for (const dapp of dapps) {
      await this.deleteDapp(dapp.slug);
    }
  }

  async getDappConfig(slug: string): Promise<DappConfig | null> {
    try {
      const configPath = `${BASE_PATH}/${slug}/dapp.config.json`;
      const content = await this.plugin.call('fileManager', 'readFile', configPath);
      if (content) {
        const config = JSON.parse(content);
        config.slug = slug;
        return this.sanitizeConfig(config);
      }
    } catch (e) {
      console.warn(`[DappManager] Failed to read config for ${slug}`, e);
    }
    return null;
  }

  async updateDappConfig(slug: string, updates: Partial<DappConfig>): Promise<DappConfig | null> {
    try {
      const configPath = `${BASE_PATH}/${slug}/dapp.config.json`;
      const content = await this.plugin.call('fileManager', 'readFile', configPath);

      if (!content) throw new Error('Config file not found');

      const currentConfig: DappConfig = JSON.parse(content);

      const newConfig: DappConfig = {
        ...currentConfig,
        ...updates,
        config: {
          ...currentConfig.config,
          ...(updates.config || {})
        },
        deployment: {
          ...currentConfig.deployment,
          ...(updates.deployment || {})
        },
        updatedAt: Date.now()
      };

      const sanitizedConfig = this.sanitizeConfig(newConfig);

      await this.plugin.call('fileManager', 'writeFile', configPath, JSON.stringify(sanitizedConfig, null, 2));
      return sanitizedConfig;

    } catch (e) {
      console.error('[DappManager] Failed to update config:', e);
      return null;
    }
  }

}