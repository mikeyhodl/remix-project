import { v4 as uuidv4 } from 'uuid';
import { PluginClient } from '@remixproject/plugin';
import { DappConfig } from '../types/dapp';

const BASE_PATH = 'dapps';

export class DappManager {
  private plugin: PluginClient;

  constructor(plugin: PluginClient) {
    this.plugin = plugin;
  }

  async ensureBasePath() {
    try {
      await this.plugin.call('fileManager', 'readdir', BASE_PATH);
    } catch (e) {
      console.log('[DappManager] Creating base path:', BASE_PATH);
      await this.plugin.call('fileManager', 'mkdir', BASE_PATH);
    }
  }

  async getDapps(): Promise<DappConfig[]> {
    try {
      await this.ensureBasePath();
      
      const files = await this.plugin.call('fileManager', 'readdir', BASE_PATH);
      if (!files) return [];

      const configs: DappConfig[] = [];

      for (const [rawPath, info] of Object.entries(files)) {
        // @ts-ignore
        if (info.isDirectory) {
          try {
            const pathParts = rawPath.split('/');
            const slug = pathParts[pathParts.length - 1];
            if (!slug || slug === BASE_PATH) continue;

            const configPath = `${BASE_PATH}/${slug}/dapp.config.json`;
            const content = await this.plugin.call('fileManager', 'readFile', configPath);
            
            if (content) {
              const config = JSON.parse(content);
              config.slug = slug;
              
              try {
                const previewPath = `${BASE_PATH}/${slug}/preview.png`;
                const previewContent = await this.plugin.call('fileManager', 'readFile', previewPath);
                if (previewContent) {
                  config.thumbnailPath = previewContent;
                }
              } catch (e) {}
              configs.push(config);
            }
          } catch (e) {
            console.warn(`[DappManager] Failed to read config for ${rawPath}`, e);
          }
        }
      }
      return configs.sort((a, b) => b.createdAt - a.createdAt);
    } catch (e) {
      console.error('[DappManager] Critical error loading dapps:', e);
      return []; 
    }
  }

  async createDapp(name: string, contractData: any): Promise<DappConfig> {
    const id = uuidv4();
    const slug = `${name.toLowerCase().replace(/[^a-z0-9]+/g, '-')}-${id.slice(0, 6)}`;
    const folderPath = `${BASE_PATH}/${slug}`;
    const timestamp = Date.now();

    const initialConfig: DappConfig = {
      _warning: "DO NOT EDIT THIS FILE MANUALLY. MANAGED BY QUICK DAPP.",
      id,
      slug,
      name,
      contract: {
        address: contractData.address,
        name: contractData.name,
        abi: contractData.abi,
        chainId: contractData.chainId,
        networkName: contractData.networkName || 'Unknown Network'
      },
      status: 'draft',
      createdAt: timestamp,
      updatedAt: timestamp,
      config: {
        title: name,
        details: 'Generated by AI',
      }
    };

    await this.plugin.call('fileManager', 'mkdir', folderPath);
    await this.saveConfig(slug, initialConfig);
    await this.plugin.call('fileManager', 'mkdir', `${folderPath}/src`);
    
    return initialConfig;
  }

  async saveConfig(slug: string, config: DappConfig): Promise<void> {
    config.updatedAt = Date.now();
    const content = JSON.stringify(config, null, 2);
    const configPath = `${BASE_PATH}/${slug}/dapp.config.json`;
    await this.plugin.call('fileManager', 'writeFile', configPath, content);
  }

  async saveGeneratedFiles(slug: string, pages: Record<string, string>) {
    const basePath = `${BASE_PATH}/${slug}`;

    for (const [rawFilename, content] of Object.entries(pages)) {
      const safeParts = rawFilename.replace(/\\/g, '/')
        .split('/')
        .filter(part => part !== '..' && part !== '.' && part !== '');

      if (safeParts.length === 0) continue;

      const fullPath = `${basePath}/${safeParts.join('/')}`;
      
      if (safeParts.length > 1) {
        const subFolders = safeParts.slice(0, -1);
        let currentPath = basePath;
        for (const folder of subFolders) {
          currentPath = `${currentPath}/${folder}`;
          try {
            await this.plugin.call('fileManager', 'mkdir', currentPath);
          } catch (e) {}
        }
      }

      await this.plugin.call('fileManager', 'writeFile', fullPath, content);
    }
  }

  async deleteDapp(slug: string): Promise<void> {
    await this.plugin.call('fileManager', 'remove', `${BASE_PATH}/${slug}`);
  }

  async deleteAllDapps(): Promise<void> {
     const dapps = await this.getDapps();
     for (const dapp of dapps) {
       await this.deleteDapp(dapp.slug);
     }
  }
}